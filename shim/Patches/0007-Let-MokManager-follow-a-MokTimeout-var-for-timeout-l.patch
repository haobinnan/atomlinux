From 93708c11083f4ca28d53b7f32d23fff47ec1d761 Mon Sep 17 00:00:00 2001
From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
Date: Thu, 5 Jul 2018 11:28:12 -0400
Subject: [PATCH 07/55] Let MokManager follow a MokTimeout var for timeout
 length for the prompt

This timeout can have the values [-1,0..0x7fff]; where -1 means "no timeout",
with MokManager going directly to the menu, and is capped to 0x7fff to avoid
unecessary long timeouts. The default remains 10, which will be used whenever
the MokTimeout variable isn't set.

Signed-off-by: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
---
 MokManager.c | 23 ++++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/MokManager.c b/MokManager.c
index 7e40a38..0767e4a 100644
--- a/MokManager.c
+++ b/MokManager.c
@@ -40,6 +40,10 @@ typedef struct {
 	CHAR16 Password[SB_PASSWORD_LEN];
 } __attribute__ ((packed)) MokDBvar;
 
+typedef struct {
+	INT32 Timeout;
+} __attribute__ ((packed)) MokTimeoutvar;
+
 static EFI_STATUS get_sha1sum(void *Data, int DataSize, UINT8 * hash)
 {
 	EFI_STATUS efi_status;
@@ -2041,7 +2045,24 @@ static int draw_countdown()
 	UINTN cols, rows;
 	CHAR16 *title[2];
 	CHAR16 *message = L"Press any key to perform MOK management";
-	int timeout = 10, wait = 10000000;
+	void *MokTimeout = NULL;
+	MokTimeoutvar *var;
+	UINTN MokTimeoutSize = 0;
+	int timeout, wait = 10000000;
+
+	efi_status = get_variable(L"MokTimeout", (UINT8 **) &MokTimeout,
+				  &MokTimeoutSize, SHIM_LOCK_GUID);
+	if (EFI_ERROR(efi_status)) {
+		timeout = 10;
+	} else {
+		var = MokTimeout;
+		timeout = (int)var->Timeout;
+		FreePool(MokTimeout);
+		LibDeleteVariable(L"MokTimeout", &SHIM_LOCK_GUID);
+	}
+
+	if (timeout < 0)
+		return timeout;
 
 	console_save_and_set_mode(&SavedMode);
 
-- 
2.17.1

